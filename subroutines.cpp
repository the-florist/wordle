/*******
 * This file contains all of the base functions that the routines in
 * functions.cpp and modes.cpp rely upon. 
 * The first section contains all functions used for printing string arrays and general maintenence. 
 * The second section contains all functions used for debugging, including print_to_debug_file, which
 *      prints a selection of data to a separate text file for examination after the run (currently 
 *      only implemented for interactive mode).
 * The third section contains all functions that compare the new guessed word to the hidden word to 
 *      determine which letters are correct.
 * The third section contains all subroutines used by the new_guess_array functions in functions.cpp
 *      to generate a new array of guesses.
*******/
#include "header.hpp"

/*******
Bookeeping functions
********/

void read_words(int total, string word_array[])
{
    /*
    This function reads the words from the WordleWords.txt file
        into an array of strings.
    */
    char reads[total][6];

    FILE *wordfile;
    wordfile = fopen("./docs/WordleWords.txt","r");

    for (int i=0; i<total; i++)
    {
        fscanf(wordfile, "%6s", reads[i]);
        word_array[i] = (string)reads[i];
    }
}

string find_unique_letters(string to_compress) 
{
    /*
    This function removes all duplicate letters from the input string.
    */
    string shortn = "";
    int len = to_compress.length();
    int doubled;

    for (int l=0; l<len; l++)
    {
        doubled = 0;
        for (int ll=0; ll<l; ll++) 
        {
            if (to_compress[l] == shortn[ll] && l != ll)
            {
                doubled++;
            }
            else
            {
                continue;
            }
        }
        
        if (doubled == 0) 
        {
            shortn += to_compress[l];
        }
        else 
        {
            continue;
        }
    }

    return shortn;
}

int nth_best(int place, float scores[], int total) 
{
    /*
    This function uses the scores generated by best_word
        to find the nth ranked word.
    */
    int counter = 0;
    int max = 0;
    float temp_scores[total];

    for(int w=1; w<total; w++) 
    {
        temp_scores[w] = scores[w];
    }
    
    while (counter<place)
    {
        for (int w=1; w<total; w++) 
        {
            if (temp_scores[w] > temp_scores[max])
            {
                max = w;
            }
            else 
            {
                continue;
            }
        }

        temp_scores[max] = 0.;
        counter++;
    }

    return max;
}

/********
Debugging functions
*********/

void check_is_word(string word, int total, string word_array[]) 
{
    /*
    This function checks that a given word is listed in WordleWords,
        the file containing all acceptable wordle words.
    */
    int count = 0;
    for (int i=0; i<total; i++) 
    {
        if (word_array[i] == word) 
        {
            count++;
        }
        else 
        {
            continue;
        }
    }

    if (count == 0) 
    {
        printf("The word you have entered is not an accepted Wordle word. Please enter a new word.\n");
        exit(EXIT_FAILURE);
    }
}

void print_string_list(string strings[], int len, string name)
{
    /*
    This function takes a list of strings, it's length and it's shortened name
        and prints them to the terminal in a nice format.
    */
    cout << "String list " << name << ": " << endl;
    for(int g=0; g<len; g++)
    {
        if (strings[g] != "")
        {
            cout << strings[g] << endl;
        }
        else
        {
            continue;
        }
    }
}

void print_to_debug_file(int round, string guess_word, string hidden_word, string pos, string lets_in_word, string pos_complement, string best)
{
    /*
    This function prints useful information to a text file called ./tools/debug_output.txt 
        which can be used to examine various logical structures in the program.
    */

    fprintf(debug_out,"Round: %i\n", round);
    fprintf(debug_out,"Guess: ");

    for (int i=0; i<5; i++)
    {
        fprintf(debug_out,"%c", guess_word[i]);
    }
    fprintf(debug_out, "\nHidden: ");
    for (int i=0; i<5; i++)
    {
        fprintf(debug_out, "%c", hidden_word[i]);
    }
    fprintf(debug_out, "\nPosition: ");
    for (int i=0; i<5; i++)
    {
        fprintf(debug_out, "%c", pos[i]);
    }
    fprintf(debug_out, "\nLetters in word: ");
    for (int i=0; i<lets_in_word.length(); i++)
    {
        fprintf(debug_out, "%c", lets_in_word[i]);
    }
    fprintf(debug_out,"\nPosition complement: ");
    for (int i=0; i<pos_complement.length(); i++)
    {
        fprintf(debug_out, "%c", pos_complement[i]);
    }
    fprintf(debug_out, "\nBest word: ");
    for (int i=0; i<5; i++)
    {
        fprintf(debug_out, "%c", best[i]);
    }
}

/********
Functions that extract info from guesses
********/

string letters_in_position(string guess_word, string hidden_word) 
{
    /*
    This function generates a new string where letters in the correct 
        position are shown and unfilled positions are given a "0" value.
    */
    string temp = "00000";
    for (int l=0; l<6; l++)
    {
        if (guess_word[l] == hidden_word[l])
        {
            temp[l] = guess_word[l];
        }
        else 
        {
            continue;
        }
    }

    return temp;
}

string letters_in_position_comp(string guess_word, string hidden_word, string lets_in_word) 
{
    /*
    This function generates a string containing all letters which have been eliminated
        by current and previous guesses.
    */
    string temp;
    string shortn_guess = find_unique_letters(guess_word);
    int is_in[5] = {0,0,0,0,0};

    if (debug==1)
    {
        cout << "Shortened guess: " << shortn_guess << endl;
    }

    /*determines if guess letter is in hidden word
        or if it has already been eliminated.*/
    for (int i=0; i<5; i++) 
    {
        for (int j=0; j<5; j++)
        {
            if (shortn_guess[i] == hidden_word[j])
            {
                is_in[i] = 1;
            }
            else 
            {
                continue;
            }
        }

        for (int k=0; k<lets_in_word.length(); k++) 
        {
            if (shortn_guess[i] == lets_in_word[k])
            {
                is_in[i] = 1;
            }
            else 
            {
                continue;
            }
        }
    }

    //adds letter to temp if it is newly eliminated.
    for (int i=0; i<5; i++)
    {
        if (is_in[i] != 1) 
        {
            temp += shortn_guess[i];
        }
    }

    return temp;
}

string letters_elsewhere(string guess_word, string hidden_word, string pos) 
{
    /*
    This function generates a string containing all letters which aren't in the 
        right position but do appear somewhere in the word.
    */
    string in_word = "";
    int l = 0;
    string hidden_temp = hidden_word;

    while (l<6)
    {
        //Removes letters that are already accounted for in temp
        for (int lh=0; lh<6; lh++)
        {
            if (guess_word[l] == pos[lh])
            {
                continue;
            }
            else if (guess_word[l] == hidden_temp[lh])
            {
                in_word += guess_word[l];
                hidden_temp[lh] = zero[0];
                break;
            }
            else
            {
                continue;
            }
        }
        
        l++;
    }

    return in_word;
}

/********
Subroutines for generating a new list of guesses
********/

string position_remover(string guess_word, string candidate, string pos) 
{
    /*
    This function eliminates a candidate if it has a letter in the same position as the guess that
        was not in the correct position.
    */
    for (int l=0; l<6; l++) 
    {
        if (candidate[l] == guess_word[l] && candidate[l] != pos[l]) 
        {
            candidate = "";
        }
        else
        {
            continue;
        }
    }

    return candidate;
}

string eliminated_letter_remover(string guess_word, string pos, string pos_comp) 
{
    /*
    This function eliminates words from the list of candidates if they contain letters
        that have been ruled out by current and previous guesses.
    */

    for (int l=0; l<5; l++) for (int ll=0; ll<pos_comp.length(); ll++)
    {
        if (guess_word[l] == pos_comp[ll] && pos[l] != pos_comp[ll]) 
        {
            guess_word = "";
        }
        else 
        {
            continue;
        }
    }

    return guess_word;
}

string prev_guess_remover(string this_guess, string word_from_array, int prev_guess_len, string prev_guesses[])
{
    /*
    This function removes a guess from the candidate array if
        it has been guessed previously.
    */
    for(int g=0; g<prev_guess_len; g++)
    {
        if (word_from_array == prev_guesses[g])
        {
            this_guess = "";
        }
        else
        {
            continue;
        }
    }

    return this_guess;
}

string make_position_guesses(int w, string pos, string word_array[])
{
    /*
    This function returns a new candidate if it contains all letters which are in the right position.
    */
    string position_guess = "";

    for (int l=0; l<5; l++)
    {
        int count = 0;
        if (pos[l] != zero[0] && pos[l] == word_array[w][l] && count == 0)
        {
            position_guess = word_array[w];
            count++;
        }

        else if (pos[l] != zero[0] && pos[l] != word_array[w][l]) 
        {
            position_guess = "";
            break;
        }

        else 
        {
            continue;
        }
    }

    return position_guess;
}
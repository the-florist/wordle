/*******
 * This file contains all of the base functions that the routines in
 * functions.cpp and modes.cpp rely upon. 
 * The first section contains all functions used for printing string arrays and general maintenence. 
 * The second section contains all functions that compare the new guessed word to the hidden word to 
 *      determine which letters are correct.
 * The third section contains all subroutines used by the new_guess_array functions in functions.cpp
 *      to generate a new array of guesses.
*******/
#include "header.hpp"

/*******
Bookeeping functions
********/

void read_words(int total, string word_array[])
{
    /*
    This function reads the words from the WordleWords.txt file
        into an array of strings.
    */
    char reads[total][6];

    FILE *wordfile;
    wordfile = fopen("./docs/WordleWords.txt","r");

    for (int i=0; i<total; i++)
    {
        fscanf(wordfile, "%6s", reads[i]);
        word_array[i] = (string)reads[i];
    }
}

void print_string_list(string strings[], int len, string name)
{
    /*
    This function takes a list of strings, it's length and it's shortened name
        and prints them to the terminal in a nice format. This is used for debugging,
        and won't be used in the final program.
    */
    cout << "String list " << name << ": " << endl;
    for(int g=0; g<len; g++)
    {
        if (strings[g] != "")
        {
            cout << strings[g] << endl;
        }
        else
        {
            continue;
        }
    }
}

void print_position_complement(string pos_comp) 
{
    /*
    This function prints the position complement in a nice way 
        which takes the specific complement formatting into account.
    */
    string zero = "0";

    if (debug != 1) 
    {
        cout << "These letters have been eliminated: ";
        for (int i=0; i<pos_comp.length(); i++)
        {
            if (pos_comp[i] != zero[0])
            {
                cout << pos_comp[i];
            }
            else 
            {
                continue;
            }
        }
        printf("\n");
    }

    else if (debug == 1)
    {
        for (int i=0; i<pos_comp.length(); i++)
        {
            cout << pos_comp[i];
        }
        printf("\n");
    }
}

void print_to_debug_file(int round, string guess, string hidden, string position, string in_word, string position_complement, string best)
{

    cout << "Printing to file..." << endl;
    fprintf(debug_out,"Round: %i\n", round);
    fprintf(debug_out,"Guess: ");
    for (int i=0; i<5; i++)
    {
        fprintf(debug_out,"%c", guess[i]);
    }
    fprintf(debug_out, "\nHidden: ");
    for (int i=0; i<5; i++){
        fprintf(debug_out, "%c", hidden[i]);
    }
    fprintf(debug_out, "\nPosition: ");
    for (int i=0; i<5; i++){
        fprintf(debug_out, "%c", position[i]);
    }
    fprintf(debug_out, "\nLetters in word: ");
    for (int i=0; i<in_word.length(); i++){
        fprintf(debug_out, "%c", in_word[i]);
    }
    fprintf(debug_out,"\nPosition complement: ");
    for (int i=0; i<position_complement.length(); i++){
        fprintf(debug_out, "%c", position_complement[i]);
    }
    fprintf(debug_out, "\nBest word: ");
    for (int i=0; i<5; i++){
        fprintf(debug_out, "%c", best[i]);
    }
}

int nth_best(int tot_words, float scores[], int place) 
{
    /*
    This function uses the scores generated by best_word
        to find the nth ranked word.
    */
    int counter = 0;
    int max = 0;
    float scores_rm[tot_words];

    for(int w=1; w<tot_words; w++) 
    {
        scores_rm[w] = scores[w];
    }
    
    while (counter<place)
    {
        for (int w=1; w<tot_words; w++) 
        {
            if (scores_rm[w] > scores_rm[max])
            {
                max = w;
            }
            else 
            {
                continue;
            }
        }

        scores_rm[max] = 0.;
        counter++;
    }

    //cout << "nth max index is: " << max << endl;
    return max;
}

/********
Functions that extract info from guesses
********/

string letters_in_position(string guess_word, string hidden_word) 
{
    /*
    This function generates a new string where letters in the correct 
        position are shown and unfilled positions are given a "0" value.
    */
    string temp = "00000";
    for (int l=0; l<6; l++)
    {
        if (guess_word[l] == hidden_word[l])
        {
            temp[l] = guess_word[l];
        }
        else 
        {
            continue;
        }
    }

    return temp;
}

string letters_in_position_comp(string guess_word, string hidden_word, string prev_comp) 
{
    /*
    This function generates a string containing all letters which have been eliminated
        by current and previous guesses.
    */
    string temp;
    string shortn = "00000";
    int is_in[5] = {0,0,0,0,0};
    string zero = "0";

    //removes duplicate letters in the guess word
    for (int l=0; l<5; l++) 
    {
        shortn[l] = guess_word[l];

        for (int ll=0; ll<l; ll++)
        {
            if (shortn[l] == shortn[ll])
            {
                shortn[l] = zero[1];
            }
            else 
            {
                continue;
            }
        }
    }

    if (debug==1)
    {
        cout << "Shortened guess: " << shortn << endl;
    }

    //determines if guess letter is in hidden word
    //or if it has already been eliminated.
    for (int i=0; i<5; i++) 
    {
        for (int j=0; j<5; j++)
        {
            if (shortn[i] == hidden_word[j])
            {
                is_in[i] = 1;
            }
            else 
            {
                continue;
            }
        }

        for (int k=0; k<prev_comp.length(); k++) 
        {
            if (shortn[i] == prev_comp[k])
            {
                is_in[i] = 1;
            }
            else 
            {
                continue;
            }
        }
    }

    //adds letter to temp if it is newly eliminated.
    for (int i=0; i<5; i++)
    {
        if (is_in[i] != 1) 
        {
            temp += shortn[i];
        }
    }

    return temp;
}

string letters_elsewhere(string guess_word, string hidden_word, string temp) 
{
    /*
    This function generates a string containing all letters which aren't in the 
        right position but do appear somewhere in the word.
    */
    string in_word = "";
    int let = 0;
    while (let < 6)
    {
        //Deals with doubled letters
        for (int lt=0; lt<let; lt++)
        {
            if (guess_word[let] == guess_word[lt])
            {
                let++;
                break;
            }

            else
            {
                continue;
            }
        }

        //Removes letters that are already accounted for in temp
        for (int lh=0; lh<6; lh++)
        {
            if (guess_word[let] == temp[lh])
            {
                continue;
            }
            else if (guess_word[let] == hidden_word[lh])
            {
                in_word += guess_word[let];
            }
            else
            {
                continue;
            }
        }
        let++;
    }

    return in_word;
}

/********
Subroutines for generating a new list of guesses
********/

string position_remover(string guess, string candidate, string temp) 
{
    /*
    This function eliminates a candidate if it has a letter in the same position as the guess that
        was not in the correct position.
    */
    for (int l=0; l<6; l++) 
    {
        if (candidate[l] == guess[l] && guess[l] != temp[l]) 
        {
            candidate = "";
        }
        else
        {
            continue;
        }
    }

    return candidate;
}

string eliminated_letter_remover(string let, string let_comp, string next_guess) 
{
    /*
    This function eliminates words from the list of candidates if they contain letters
        that have been ruled out by current and previous guesses.
    */

    for (int l=0; l<5; l++) for (int ll=0; ll<let_comp.length(); ll++)
    {
        if (next_guess[l] == let_comp[ll] && let[l] != let_comp[ll]) 
        {
            next_guess = "";
        }
        else 
        {
            continue;
        }
    }

    return next_guess;
}

string prev_guess_remover(int prev_guess_len, string prev_guesses[], string this_guess, string word_from_array)
{
    /*
    This function removes guesses from the candidate array if they have been guessed previously.
    */
    for(int g=0; g<prev_guess_len; g++)
    {
        if (word_from_array == prev_guesses[g])
        {
            this_guess = "";
        }
        else
        {
            continue;
        }
    }

    return this_guess;
}

string make_position_guesses(int word, string all_words[], string temp)
{
    /*
    This function returns a new candidate if it contains all letters which are in the right position.
    */
    string position_guess = "";
    string zero = "0";

    for (int l=0; l<5; l++)
    {
        int count = 0;
        if (temp[l] != zero[0] && temp[l] == all_words[word][l] && count == 0)
        {
            position_guess = all_words[word];
            count++;
        }

        else if (temp[l] != zero[0] && temp[l] != all_words[word][l]) 
        {
            position_guess = "";
            break;
        }

        else 
        {
            continue;
        }
    }

    return position_guess;
}